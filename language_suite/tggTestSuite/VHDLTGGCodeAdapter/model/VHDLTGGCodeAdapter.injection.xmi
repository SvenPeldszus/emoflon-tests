<?xml version="1.0" encoding="ASCII"?>
<sdmUtil:CompilerInjection xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:sdmUtil="platform:/plugin/SDMLanguage/model/SDMLanguage.ecore#//sdmUtil">
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName.name&quot;, true, csp);&#xD;&#xA;var_gateName_name.setValue(gateName.getName());&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName.name&quot;, true, csp);&#xD;&#xA;var_entityName_name.setValue(entityName.getName());&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_gateName_name,var_entityName_name);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;entity&quot;, entity);&#xA;match.registerObject(&quot;entityName&quot;, entityName);&#xA;match.registerObject(&quot;file&quot;, file);&#xA;match.registerObject(&quot;gate&quot;, gate);&#xA;match.registerObject(&quot;gateName&quot;, gateName);&#xA;match.registerObject(&quot;vhdl&quot;, vhdl);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName.name&quot;, true, csp);&#xD;&#xA;var_entityName_name.setValue(entityName.getName());&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName.name&quot;, true, csp);&#xD;&#xA;var_gateName_name.setValue(gateName.getName());&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_composite_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;composite.name&quot;, csp);&#xD;&#xA;var_composite_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_entityName_name,var_composite_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_gateName_name,var_composite_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityName&quot;,entityName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file2spec&quot;,file2spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file&quot;,file);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate&quot;,gate);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateName&quot;,gateName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;spec&quot;,spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdl&quot;,vhdl);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;composite&quot;, composite);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entity&quot;, entity);&#xA;ruleresult.registerObject(&quot;entityName&quot;, entityName);&#xA;ruleresult.registerObject(&quot;file2spec&quot;, file2spec);&#xA;ruleresult.registerObject(&quot;file&quot;, file);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gate&quot;, gate);&#xA;ruleresult.registerObject(&quot;gateName&quot;, gateName);&#xA;ruleresult.registerObject(&quot;spec&quot;, spec);&#xA;ruleresult.registerObject(&quot;vhdl&quot;, vhdl);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;entity&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;entityName&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;gate&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;gateName&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;composite&quot;, composite);&#xA;match.registerObject(&quot;spec&quot;, spec);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_composite_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;composite.name&quot;, true, csp);&#xD;&#xA;var_composite_name.setValue(composite.getName());&#xD;&#xA;var_composite_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName.name&quot;, csp);&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName.name&quot;, csp);&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;Eq eq_1 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(eq_1);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_entityName_name,var_composite_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_gateName_name,var_composite_name);&#xD;&#xA;eq_1.setRuleName(&quot;&quot;);&#xD;&#xA;eq_1.solve(var_gateName_name,var_entityName_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file2spec&quot;,file2spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file&quot;,file);&#xD;&#xA;isApplicableMatch.registerObject(&quot;spec&quot;,spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdl&quot;,vhdl);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;composite&quot;, composite);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entity&quot;, entity);&#xA;ruleresult.registerObject(&quot;entityName&quot;, entityName);&#xA;ruleresult.registerObject(&quot;file2spec&quot;, file2spec);&#xA;ruleresult.registerObject(&quot;file&quot;, file);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gate&quot;, gate);&#xA;ruleresult.registerObject(&quot;gateName&quot;, gateName);&#xA;ruleresult.registerObject(&quot;spec&quot;, spec);&#xA;ruleresult.registerObject(&quot;vhdl&quot;, vhdl);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;composite&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getCompositeBlock());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;entity&quot;, entity);&#xA;match.registerObject(&quot;portName&quot;, portName);&#xA;match.registerObject(&quot;portNode&quot;, portNode);&#xA;match.registerObject(&quot;typeNode&quot;, typeNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, csp);&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portName&quot;,portName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portNode&quot;,portNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;typeNode&quot;,typeNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;composite&quot;, composite);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entity&quot;, entity);&#xA;ruleresult.registerObject(&quot;node2inport&quot;, node2inport);&#xA;ruleresult.registerObject(&quot;port&quot;, port);&#xA;ruleresult.registerObject(&quot;portName&quot;, portName);&#xA;ruleresult.registerObject(&quot;portNode&quot;, portNode);&#xA;ruleresult.registerObject(&quot;typeNode&quot;, typeNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;portName&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;portNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;typeNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;composite&quot;, composite);&#xA;match.registerObject(&quot;port&quot;, port);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, csp);&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;port&quot;,port);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;composite&quot;, composite);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entity&quot;, entity);&#xA;ruleresult.registerObject(&quot;node2inport&quot;, node2inport);&#xA;ruleresult.registerObject(&quot;port&quot;, port);&#xA;ruleresult.registerObject(&quot;portName&quot;, portName);&#xA;ruleresult.registerObject(&quot;portNode&quot;, portNode);&#xA;ruleresult.registerObject(&quot;typeNode&quot;, typeNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;port&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getInputPort());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;file&quot;, file);&#xA;match.registerObject(&quot;vhdl&quot;, vhdl);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;Variable literal0 = CSPFactoryHelper.eINSTANCE.createVariable(&quot;literal0&quot;, true, csp);&#xD;&#xA;literal0.setValue(&quot;.vhdl&quot;);&#xD;&#xA;literal0.setType(&quot;&quot;);&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_file_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;file.name&quot;, true, csp);&#xD;&#xA;var_file_name.setValue(file.getName());&#xD;&#xA;var_file_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_spec_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;spec.name&quot;, csp);&#xD;&#xA;var_spec_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;AddPrefix addPrefix = new AddPrefix();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(addPrefix);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;addPrefix.setRuleName(&quot;&quot;);&#xD;&#xA;addPrefix.solve(var_spec_name,literal0,var_file_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;file&quot;,file);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdl&quot;,vhdl);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;file2spec&quot;, file2spec);&#xA;ruleresult.registerObject(&quot;file&quot;, file);&#xA;ruleresult.registerObject(&quot;spec&quot;, spec);&#xA;ruleresult.registerObject(&quot;vhdl&quot;, vhdl);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;file&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.File&quot;) &amp;&amp; match.getObject(&quot;vhdl&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;spec&quot;, spec);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;Variable literal0 = CSPFactoryHelper.eINSTANCE.createVariable(&quot;literal0&quot;, true, csp);&#xD;&#xA;literal0.setValue(&quot;.vhdl&quot;);&#xD;&#xA;literal0.setType(&quot;&quot;);&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_spec_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;spec.name&quot;, true, csp);&#xD;&#xA;var_spec_name.setValue(spec.getName());&#xD;&#xA;var_spec_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_file_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;file.name&quot;, csp);&#xD;&#xA;var_file_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;AddPrefix addPrefix = new AddPrefix();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(addPrefix);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;addPrefix.setRuleName(&quot;&quot;);&#xD;&#xA;addPrefix.solve(var_spec_name,literal0,var_file_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;spec&quot;,spec);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;file2spec&quot;, file2spec);&#xA;ruleresult.registerObject(&quot;file&quot;, file);&#xA;ruleresult.registerObject(&quot;spec&quot;, spec);&#xA;ruleresult.registerObject(&quot;vhdl&quot;, vhdl);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;spec&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getVHDLSpecification());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;portNode&quot;, portNode);&#xA;match.registerObject(&quot;typeNode&quot;, typeNode);&#xA;match.registerObject(&quot;entity&quot;, entity);&#xA;match.registerObject(&quot;portName&quot;, portName);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, csp);&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portNode&quot;,portNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;typeNode&quot;,typeNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portName&quot;,portName);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;composite&quot;, composite);&#xA;ruleresult.registerObject(&quot;node2outport&quot;, node2outport);&#xA;ruleresult.registerObject(&quot;port&quot;, port);&#xA;ruleresult.registerObject(&quot;portNode&quot;, portNode);&#xA;ruleresult.registerObject(&quot;typeNode&quot;, typeNode);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entity&quot;, entity);&#xA;ruleresult.registerObject(&quot;portName&quot;, portName);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;portNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;typeNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;portName&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;composite&quot;, composite);&#xA;match.registerObject(&quot;port&quot;, port);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, csp);&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;port&quot;,port);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;composite&quot;, composite);&#xA;ruleresult.registerObject(&quot;node2outport&quot;, node2outport);&#xA;ruleresult.registerObject(&quot;port&quot;, port);&#xA;ruleresult.registerObject(&quot;portNode&quot;, portNode);&#xA;ruleresult.registerObject(&quot;typeNode&quot;, typeNode);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entity&quot;, entity);&#xA;ruleresult.registerObject(&quot;portName&quot;, portName);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;port&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getOutputPort());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;match.registerObject(&quot;inNode2&quot;, inNode2);&#xA;match.registerObject(&quot;entityNode&quot;, entityNode);&#xA;match.registerObject(&quot;inputPortNode2&quot;, inputPortNode2);&#xA;match.registerObject(&quot;left&quot;, left);&#xA;match.registerObject(&quot;right&quot;, right);&#xA;match.registerObject(&quot;outNode&quot;, outNode);&#xA;match.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;match.registerObject(&quot;inNode&quot;, inNode);&#xA;match.registerObject(&quot;gateNode&quot;, gateNode);&#xA;match.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;match.registerObject(&quot;mapping&quot;, mapping);&#xA;match.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;match.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expressionNode&quot;,expressionNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;left&quot;,left);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;right&quot;,right);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;mapping&quot;,mapping);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;andNode2Gate&quot;, andNode2Gate);&#xA;ruleresult.registerObject(&quot;expression&quot;, expression);&#xA;ruleresult.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;ruleresult.registerObject(&quot;leftPort&quot;, leftPort);&#xA;ruleresult.registerObject(&quot;out&quot;, out);&#xA;ruleresult.registerObject(&quot;rightPort&quot;, rightPort);&#xA;ruleresult.registerObject(&quot;inNode2&quot;, inNode2);&#xA;ruleresult.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;ruleresult.registerObject(&quot;entityNode&quot;, entityNode);&#xA;ruleresult.registerObject(&quot;inputPortNode2&quot;, inputPortNode2);&#xA;ruleresult.registerObject(&quot;left&quot;, left);&#xA;ruleresult.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;ruleresult.registerObject(&quot;node2composite&quot;, node2composite);&#xA;ruleresult.registerObject(&quot;node2inputPort2&quot;, node2inputPort2);&#xA;ruleresult.registerObject(&quot;right&quot;, right);&#xA;ruleresult.registerObject(&quot;rightExtern&quot;, rightExtern);&#xA;ruleresult.registerObject(&quot;outNode&quot;, outNode);&#xA;ruleresult.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;ruleresult.registerObject(&quot;inNode&quot;, inNode);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gateNode&quot;, gateNode);&#xA;ruleresult.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;ruleresult.registerObject(&quot;mapping&quot;, mapping);&#xA;ruleresult.registerObject(&quot;node2InputPort1&quot;, node2InputPort1);&#xA;ruleresult.registerObject(&quot;node2OutputPort&quot;, node2OutputPort);&#xA;ruleresult.registerObject(&quot;outExternal&quot;, outExternal);&#xA;ruleresult.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;ruleresult.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;expressionNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;left&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;right&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;mapping&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;expression&quot;, expression);&#xA;match.registerObject(&quot;leftPort&quot;, leftPort);&#xA;match.registerObject(&quot;out&quot;, out);&#xA;match.registerObject(&quot;rightPort&quot;, rightPort);&#xA;match.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;match.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;match.registerObject(&quot;rightExtern&quot;, rightExtern);&#xA;match.registerObject(&quot;outExternal&quot;, outExternal);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, csp);&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, csp);&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, csp);&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, csp);&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;Eq eq_1 = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(eq_1);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;eq_1.setRuleName(&quot;&quot;);&#xD;&#xA;eq_1.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expression&quot;,expression);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftPort&quot;,leftPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;out&quot;,out);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightPort&quot;,rightPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;andNode2Gate&quot;, andNode2Gate);&#xA;ruleresult.registerObject(&quot;expression&quot;, expression);&#xA;ruleresult.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;ruleresult.registerObject(&quot;leftPort&quot;, leftPort);&#xA;ruleresult.registerObject(&quot;out&quot;, out);&#xA;ruleresult.registerObject(&quot;rightPort&quot;, rightPort);&#xA;ruleresult.registerObject(&quot;inNode2&quot;, inNode2);&#xA;ruleresult.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;ruleresult.registerObject(&quot;entityNode&quot;, entityNode);&#xA;ruleresult.registerObject(&quot;inputPortNode2&quot;, inputPortNode2);&#xA;ruleresult.registerObject(&quot;left&quot;, left);&#xA;ruleresult.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;ruleresult.registerObject(&quot;node2composite&quot;, node2composite);&#xA;ruleresult.registerObject(&quot;node2inputPort2&quot;, node2inputPort2);&#xA;ruleresult.registerObject(&quot;right&quot;, right);&#xA;ruleresult.registerObject(&quot;rightExtern&quot;, rightExtern);&#xA;ruleresult.registerObject(&quot;outNode&quot;, outNode);&#xA;ruleresult.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;ruleresult.registerObject(&quot;inNode&quot;, inNode);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gateNode&quot;, gateNode);&#xA;ruleresult.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;ruleresult.registerObject(&quot;mapping&quot;, mapping);&#xA;ruleresult.registerObject(&quot;node2InputPort1&quot;, node2InputPort1);&#xA;ruleresult.registerObject(&quot;node2OutputPort&quot;, node2OutputPort);&#xA;ruleresult.registerObject(&quot;outExternal&quot;, outExternal);&#xA;ruleresult.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;ruleresult.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;expression&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getAndGate()) &amp;&amp; match.getObject(&quot;leftPort&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getInputPort()) &amp;&amp; match.getObject(&quot;out&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getOutputPort()) &amp;&amp; match.getObject(&quot;rightPort&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getInputPort());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;match.registerObject(&quot;inNode2&quot;, inNode2);&#xA;match.registerObject(&quot;entityNode&quot;, entityNode);&#xA;match.registerObject(&quot;inputPortNode2&quot;, inputPortNode2);&#xA;match.registerObject(&quot;left&quot;, left);&#xA;match.registerObject(&quot;right&quot;, right);&#xA;match.registerObject(&quot;outNode&quot;, outNode);&#xA;match.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;match.registerObject(&quot;inNode&quot;, inNode);&#xA;match.registerObject(&quot;gateNode&quot;, gateNode);&#xA;match.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;match.registerObject(&quot;mapping&quot;, mapping);&#xA;match.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;match.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expressionNode&quot;,expressionNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;left&quot;,left);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;right&quot;,right);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;mapping&quot;,mapping);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;expression&quot;, expression);&#xA;ruleresult.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;ruleresult.registerObject(&quot;leftPort&quot;, leftPort);&#xA;ruleresult.registerObject(&quot;orNode2Gate&quot;, orNode2Gate);&#xA;ruleresult.registerObject(&quot;out&quot;, out);&#xA;ruleresult.registerObject(&quot;rightPort&quot;, rightPort);&#xA;ruleresult.registerObject(&quot;inNode2&quot;, inNode2);&#xA;ruleresult.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;ruleresult.registerObject(&quot;entityNode&quot;, entityNode);&#xA;ruleresult.registerObject(&quot;inputPortNode2&quot;, inputPortNode2);&#xA;ruleresult.registerObject(&quot;left&quot;, left);&#xA;ruleresult.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;ruleresult.registerObject(&quot;node2composite&quot;, node2composite);&#xA;ruleresult.registerObject(&quot;node2inputPort2&quot;, node2inputPort2);&#xA;ruleresult.registerObject(&quot;right&quot;, right);&#xA;ruleresult.registerObject(&quot;rightExtern&quot;, rightExtern);&#xA;ruleresult.registerObject(&quot;outNode&quot;, outNode);&#xA;ruleresult.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;ruleresult.registerObject(&quot;inNode&quot;, inNode);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gateNode&quot;, gateNode);&#xA;ruleresult.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;ruleresult.registerObject(&quot;mapping&quot;, mapping);&#xA;ruleresult.registerObject(&quot;node2InputPort1&quot;, node2InputPort1);&#xA;ruleresult.registerObject(&quot;node2OutputPort&quot;, node2OutputPort);&#xA;ruleresult.registerObject(&quot;outExternal&quot;, outExternal);&#xA;ruleresult.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;ruleresult.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;expressionNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;left&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;right&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;mapping&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;expression&quot;, expression);&#xA;match.registerObject(&quot;leftPort&quot;, leftPort);&#xA;match.registerObject(&quot;out&quot;, out);&#xA;match.registerObject(&quot;rightPort&quot;, rightPort);&#xA;match.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;match.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;match.registerObject(&quot;rightExtern&quot;, rightExtern);&#xA;match.registerObject(&quot;outExternal&quot;, outExternal);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, csp);&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, csp);&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, csp);&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, csp);&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;Eq eq_1 = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(eq_1);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;eq_1.setRuleName(&quot;&quot;);&#xD;&#xA;eq_1.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expression&quot;,expression);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftPort&quot;,leftPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;out&quot;,out);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightPort&quot;,rightPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;expression&quot;, expression);&#xA;ruleresult.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;ruleresult.registerObject(&quot;leftPort&quot;, leftPort);&#xA;ruleresult.registerObject(&quot;orNode2Gate&quot;, orNode2Gate);&#xA;ruleresult.registerObject(&quot;out&quot;, out);&#xA;ruleresult.registerObject(&quot;rightPort&quot;, rightPort);&#xA;ruleresult.registerObject(&quot;inNode2&quot;, inNode2);&#xA;ruleresult.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;ruleresult.registerObject(&quot;entityNode&quot;, entityNode);&#xA;ruleresult.registerObject(&quot;inputPortNode2&quot;, inputPortNode2);&#xA;ruleresult.registerObject(&quot;left&quot;, left);&#xA;ruleresult.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;ruleresult.registerObject(&quot;node2composite&quot;, node2composite);&#xA;ruleresult.registerObject(&quot;node2inputPort2&quot;, node2inputPort2);&#xA;ruleresult.registerObject(&quot;right&quot;, right);&#xA;ruleresult.registerObject(&quot;rightExtern&quot;, rightExtern);&#xA;ruleresult.registerObject(&quot;outNode&quot;, outNode);&#xA;ruleresult.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;ruleresult.registerObject(&quot;inNode&quot;, inNode);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gateNode&quot;, gateNode);&#xA;ruleresult.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;ruleresult.registerObject(&quot;mapping&quot;, mapping);&#xA;ruleresult.registerObject(&quot;node2InputPort1&quot;, node2InputPort1);&#xA;ruleresult.registerObject(&quot;node2OutputPort&quot;, node2OutputPort);&#xA;ruleresult.registerObject(&quot;outExternal&quot;, outExternal);&#xA;ruleresult.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;ruleresult.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;expression&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getOrGate()) &amp;&amp; match.getObject(&quot;leftPort&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getInputPort()) &amp;&amp; match.getObject(&quot;out&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getOutputPort()) &amp;&amp; match.getObject(&quot;rightPort&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getInputPort());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isAppropriate_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;match.registerObject(&quot;port&quot;, port);&#xA;match.registerObject(&quot;outNode&quot;, outNode);&#xA;match.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;match.registerObject(&quot;inNode&quot;, inNode);&#xA;match.registerObject(&quot;entityNode&quot;, entityNode);&#xA;match.registerObject(&quot;gateNode&quot;, gateNode);&#xA;match.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;match.registerObject(&quot;mapping&quot;, mapping);&#xA;match.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;match.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/registerObjectsToMatch_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isAppropriate_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expressionNode&quot;,expressionNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;port&quot;,port);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;mapping&quot;,mapping);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isApplicable_solveCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isApplicable_checkCsp_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;expression&quot;, expression);&#xA;ruleresult.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;ruleresult.registerObject(&quot;in&quot;, in);&#xA;ruleresult.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;ruleresult.registerObject(&quot;notNode2Gate&quot;, notNode2Gate);&#xA;ruleresult.registerObject(&quot;out&quot;, out);&#xA;ruleresult.registerObject(&quot;port&quot;, port);&#xA;ruleresult.registerObject(&quot;outNode&quot;, outNode);&#xA;ruleresult.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;ruleresult.registerObject(&quot;inNode&quot;, inNode);&#xA;ruleresult.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entityNode&quot;, entityNode);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gateNode&quot;, gateNode);&#xA;ruleresult.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;ruleresult.registerObject(&quot;mapping&quot;, mapping);&#xA;ruleresult.registerObject(&quot;node2InputPort1&quot;, node2InputPort1);&#xA;ruleresult.registerObject(&quot;node2OutputPort&quot;, node2OutputPort);&#xA;ruleresult.registerObject(&quot;outExternal&quot;, outExternal);&#xA;ruleresult.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;ruleresult.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/registerObjects_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;expressionNode&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;port&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;) &amp;&amp; match.getObject(&quot;mapping&quot;).eClass().getInstanceClassName().equals(&quot;MocaTree.Node&quot;);">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/checkTypes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isAppropriate_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="match.registerObject(&quot;expression&quot;, expression);&#xA;match.registerObject(&quot;in&quot;, in);&#xA;match.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;match.registerObject(&quot;out&quot;, out);&#xA;match.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;match.registerObject(&quot;outExternal&quot;, outExternal);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/registerObjectsToMatch_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isAppropriate_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, csp);&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, csp);&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, csp);&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_port_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expression&quot;,expression);&#xD;&#xA;isApplicableMatch.registerObject(&quot;in&quot;,in);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;out&quot;,out);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isApplicable_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isApplicable_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="ruleresult.registerObject(&quot;expression&quot;, expression);&#xA;ruleresult.registerObject(&quot;expressionNode&quot;, expressionNode);&#xA;ruleresult.registerObject(&quot;in&quot;, in);&#xA;ruleresult.registerObject(&quot;leftExtern&quot;, leftExtern);&#xA;ruleresult.registerObject(&quot;notNode2Gate&quot;, notNode2Gate);&#xA;ruleresult.registerObject(&quot;out&quot;, out);&#xA;ruleresult.registerObject(&quot;port&quot;, port);&#xA;ruleresult.registerObject(&quot;outNode&quot;, outNode);&#xA;ruleresult.registerObject(&quot;outputPortNodeName&quot;, outputPortNodeName);&#xA;ruleresult.registerObject(&quot;inNode&quot;, inNode);&#xA;ruleresult.registerObject(&quot;compositeBlock&quot;, compositeBlock);&#xA;ruleresult.registerObject(&quot;entity2composite&quot;, entity2composite);&#xA;ruleresult.registerObject(&quot;entityNode&quot;, entityNode);&#xA;ruleresult.registerObject(&quot;gate2composite&quot;, gate2composite);&#xA;ruleresult.registerObject(&quot;gateNode&quot;, gateNode);&#xA;ruleresult.registerObject(&quot;inputPortNode1&quot;, inputPortNode1);&#xA;ruleresult.registerObject(&quot;mapping&quot;, mapping);&#xA;ruleresult.registerObject(&quot;node2InputPort1&quot;, node2InputPort1);&#xA;ruleresult.registerObject(&quot;node2OutputPort&quot;, node2OutputPort);&#xA;ruleresult.registerObject(&quot;outExternal&quot;, outExternal);&#xA;ruleresult.registerObject(&quot;outputPortNode&quot;, outputPortNode);&#xA;ruleresult.registerObject(&quot;vhdlNode&quot;, vhdlNode);&#xA;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/registerObjects_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return true &amp;&amp; match.getObject(&quot;expression&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getNotGate()) &amp;&amp; match.getObject(&quot;in&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getInputPort()) &amp;&amp; match.getObject(&quot;out&quot;).eClass().equals(VHDLModel.VHDLModelPackage.eINSTANCE.getOutputPort());">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/checkTypes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Entity2CompositeBlock&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForComposite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;composite&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock composite = (VHDLModel.CompositeBlock) matchForComposite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity&quot;)).findAny();&#xD;&#xA;MocaTree.Node entity = (MocaTree.Node) matchForEntity.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityName&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityName = (MocaTree.Node) matchForEntityName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile2spec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file2spec&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.FileToVHDLSpecification file2spec = (VHDLTGGCodeAdapter.FileToVHDLSpecification) matchForFile2spec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file&quot;)).findAny();&#xD;&#xA;MocaTree.File file = (MocaTree.File) matchForFile.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate&quot;)).findAny();&#xD;&#xA;MocaTree.Node gate = (MocaTree.Node) matchForGate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateName&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateName = (MocaTree.Node) matchForGateName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForSpec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;spec&quot;)).findAny();&#xD;&#xA;VHDLModel.VHDLSpecification spec = (VHDLModel.VHDLSpecification) matchForSpec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdl = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdl&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdl = (MocaTree.Node) matchForVhdl.get().getNode();&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(entity.getIndex() == 1)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!gate.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(gate.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!(gateName.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!vhdl.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName&quot;, true, csp);&#xD;&#xA;var_entityName_name.setValue(entityName.getName());&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_composite_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;composite&quot;, true, csp);&#xD;&#xA;var_composite_name.setValue(composite.getName());&#xD;&#xA;var_composite_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName&quot;, true, csp);&#xD;&#xA;var_gateName_name.setValue(gateName.getName());&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;Eq eq2 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq2);&#xA;&#xA;eq0.setRuleName(&quot;Entity2CompositeBlock&quot;);&#xD;&#xA;eq0.solve(var_gateName_name,var_entityName_name);&#xA;&#xA;eq1.setRuleName(&quot;Entity2CompositeBlock&quot;);&#xD;&#xA;eq1.solve(var_entityName_name,var_composite_name);&#xA;&#xA;eq2.setRuleName(&quot;Entity2CompositeBlock&quot;);&#xD;&#xA;eq2.solve(var_gateName_name,var_composite_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_composite_name.setBound(false);&#xD;&#xA;&#x9;var_composite_name.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_gateName_name,var_entityName_name);&#xD;&#xA;&#x9;eq1.solve(var_entityName_name,var_composite_name);&#xD;&#xA;&#x9;eq2.solve(var_gateName_name,var_composite_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;composite.setName((String) var_composite_name.getValue());&#xD;&#xA;&#x9;&#x9;composite.setName((String) var_composite_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Entity2CompositeBlock&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForComposite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;composite&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock composite = (VHDLModel.CompositeBlock) matchForComposite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity&quot;)).findAny();&#xD;&#xA;MocaTree.Node entity = (MocaTree.Node) matchForEntity.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityName&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityName = (MocaTree.Node) matchForEntityName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile2spec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file2spec&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.FileToVHDLSpecification file2spec = (VHDLTGGCodeAdapter.FileToVHDLSpecification) matchForFile2spec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file&quot;)).findAny();&#xD;&#xA;MocaTree.File file = (MocaTree.File) matchForFile.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate&quot;)).findAny();&#xD;&#xA;MocaTree.Node gate = (MocaTree.Node) matchForGate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateName&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateName = (MocaTree.Node) matchForGateName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForSpec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;spec&quot;)).findAny();&#xD;&#xA;VHDLModel.VHDLSpecification spec = (VHDLModel.VHDLSpecification) matchForSpec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdl = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdl&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdl = (MocaTree.Node) matchForVhdl.get().getNode();&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(entity.getIndex() == 1)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!gate.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(gate.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!(gateName.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!vhdl.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName&quot;, true, csp);&#xD;&#xA;var_entityName_name.setValue(entityName.getName());&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_composite_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;composite&quot;, true, csp);&#xD;&#xA;var_composite_name.setValue(composite.getName());&#xD;&#xA;var_composite_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName&quot;, true, csp);&#xD;&#xA;var_gateName_name.setValue(gateName.getName());&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;Eq eq2 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq2);&#xA;&#xA;eq0.setRuleName(&quot;Entity2CompositeBlock&quot;);&#xD;&#xA;eq0.solve(var_entityName_name,var_composite_name);&#xA;&#xA;eq1.setRuleName(&quot;Entity2CompositeBlock&quot;);&#xD;&#xA;eq1.solve(var_gateName_name,var_composite_name);&#xA;&#xA;eq2.setRuleName(&quot;Entity2CompositeBlock&quot;);&#xD;&#xA;eq2.solve(var_gateName_name,var_entityName_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_entityName_name.setBound(false);&#xD;&#xA;&#x9;var_gateName_name.setBound(false);&#xD;&#xA;&#x9;var_entityName_name.setBound(false);&#xD;&#xA;&#x9;var_gateName_name.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_entityName_name,var_composite_name);&#xD;&#xA;&#x9;eq1.solve(var_gateName_name,var_composite_name);&#xD;&#xA;&#x9;eq2.solve(var_gateName_name,var_entityName_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;entityName.setName((String) var_entityName_name.getValue());&#xD;&#xA;&#x9;&#x9;gateName.setName((String) var_gateName_name.getValue());&#xD;&#xA;&#x9;&#x9;entityName.setName((String) var_entityName_name.getValue());&#xD;&#xA;&#x9;&#x9;gateName.setName((String) var_gateName_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;HandleInPort&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForComposite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;composite&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock composite = (VHDLModel.CompositeBlock) matchForComposite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity&quot;)).findAny();&#xD;&#xA;MocaTree.Node entity = (MocaTree.Node) matchForEntity.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2inport = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2inport&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2inport = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2inport.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;port&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort port = (VHDLModel.InputPort) matchForPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portName&quot;)).findAny();&#xD;&#xA;MocaTree.Node portName = (MocaTree.Node) matchForPortName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node portNode = (MocaTree.Node) matchForPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForTypeNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;typeNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node typeNode = (MocaTree.Node) matchForTypeNode.get().getNode();&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!portNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!typeNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;eq0.setRuleName(&quot;HandleInPort&quot;);&#xD;&#xA;eq0.solve(var_portName_name,var_port_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_port_name.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_portName_name,var_port_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;port.setName((String) var_port_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;HandleInPort&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForComposite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;composite&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock composite = (VHDLModel.CompositeBlock) matchForComposite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity&quot;)).findAny();&#xD;&#xA;MocaTree.Node entity = (MocaTree.Node) matchForEntity.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2inport = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2inport&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2inport = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2inport.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;port&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort port = (VHDLModel.InputPort) matchForPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portName&quot;)).findAny();&#xD;&#xA;MocaTree.Node portName = (MocaTree.Node) matchForPortName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node portNode = (MocaTree.Node) matchForPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForTypeNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;typeNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node typeNode = (MocaTree.Node) matchForTypeNode.get().getNode();&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!portNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!typeNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;eq0.setRuleName(&quot;HandleInPort&quot;);&#xD;&#xA;eq0.solve(var_portName_name,var_port_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_portName_name.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_portName_name,var_port_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;portName.setName((String) var_portName_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;File2VHDLSpec&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile2spec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file2spec&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.FileToVHDLSpecification file2spec = (VHDLTGGCodeAdapter.FileToVHDLSpecification) matchForFile2spec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file&quot;)).findAny();&#xD;&#xA;MocaTree.File file = (MocaTree.File) matchForFile.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForSpec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;spec&quot;)).findAny();&#xD;&#xA;VHDLModel.VHDLSpecification spec = (VHDLModel.VHDLSpecification) matchForSpec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdl = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdl&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdl = (MocaTree.Node) matchForVhdl.get().getNode();&#xA;&#xA;if(!vhdl.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_spec_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;spec&quot;, true, csp);&#xD;&#xA;var_spec_name.setValue(spec.getName());&#xD;&#xA;var_spec_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_literal0 = CSPFactoryHelper.eINSTANCE.createVariable(&quot;literal&quot;, true, csp);&#xD;&#xA;var_literal0.setValue(&quot;.vhdl&quot;);&#xD;&#xA;var_literal0.setType(&quot;&quot;);&#xA;&#xA;Variable var_file_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;file&quot;, true, csp);&#xD;&#xA;var_file_name.setValue(file.getName());&#xD;&#xA;var_file_name.setType(&quot;String&quot;);&#xA;&#xA;AddPrefix addPrefix0 = new AddPrefix();&#xD;&#xA;csp.getConstraints().add(addPrefix0);&#xA;&#xA;addPrefix0.setRuleName(&quot;File2VHDLSpec&quot;);&#xD;&#xA;addPrefix0.solve(var_spec_name,var_literal0,var_file_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_spec_name.setBound(false);&#xD;&#xA;&#x9;addPrefix0.solve(var_spec_name,var_literal0,var_file_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;spec.setName((String) var_spec_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;File2VHDLSpec&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile2spec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file2spec&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.FileToVHDLSpecification file2spec = (VHDLTGGCodeAdapter.FileToVHDLSpecification) matchForFile2spec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForFile = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;file&quot;)).findAny();&#xD;&#xA;MocaTree.File file = (MocaTree.File) matchForFile.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForSpec = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;spec&quot;)).findAny();&#xD;&#xA;VHDLModel.VHDLSpecification spec = (VHDLModel.VHDLSpecification) matchForSpec.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdl = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdl&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdl = (MocaTree.Node) matchForVhdl.get().getNode();&#xA;&#xA;if(!vhdl.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_spec_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;spec&quot;, true, csp);&#xD;&#xA;var_spec_name.setValue(spec.getName());&#xD;&#xA;var_spec_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_literal0 = CSPFactoryHelper.eINSTANCE.createVariable(&quot;literal&quot;, true, csp);&#xD;&#xA;var_literal0.setValue(&quot;.vhdl&quot;);&#xD;&#xA;var_literal0.setType(&quot;&quot;);&#xA;&#xA;Variable var_file_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;file&quot;, true, csp);&#xD;&#xA;var_file_name.setValue(file.getName());&#xD;&#xA;var_file_name.setType(&quot;String&quot;);&#xA;&#xA;AddPrefix addPrefix0 = new AddPrefix();&#xD;&#xA;csp.getConstraints().add(addPrefix0);&#xA;&#xA;addPrefix0.setRuleName(&quot;File2VHDLSpec&quot;);&#xD;&#xA;addPrefix0.solve(var_spec_name,var_literal0,var_file_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_file_name.setBound(false);&#xD;&#xA;&#x9;addPrefix0.solve(var_spec_name,var_literal0,var_file_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;file.setName((String) var_file_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;HandleOutPort&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForComposite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;composite&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock composite = (VHDLModel.CompositeBlock) matchForComposite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2outport = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2outport&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2outport = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2outport.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;port&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort port = (VHDLModel.OutputPort) matchForPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node portNode = (MocaTree.Node) matchForPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForTypeNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;typeNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node typeNode = (MocaTree.Node) matchForTypeNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity&quot;)).findAny();&#xD;&#xA;MocaTree.Node entity = (MocaTree.Node) matchForEntity.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portName&quot;)).findAny();&#xD;&#xA;MocaTree.Node portName = (MocaTree.Node) matchForPortName.get().getNode();&#xA;&#xA;if(!portNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!typeNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;eq0.setRuleName(&quot;HandleOutPort&quot;);&#xD;&#xA;eq0.solve(var_portName_name,var_port_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_port_name.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_portName_name,var_port_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;port.setName((String) var_port_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;HandleOutPort&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForComposite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;composite&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock composite = (VHDLModel.CompositeBlock) matchForComposite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2outport = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2outport&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2outport = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2outport.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;port&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort port = (VHDLModel.OutputPort) matchForPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node portNode = (MocaTree.Node) matchForPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForTypeNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;typeNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node typeNode = (MocaTree.Node) matchForTypeNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity&quot;)).findAny();&#xD;&#xA;MocaTree.Node entity = (MocaTree.Node) matchForEntity.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPortName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;portName&quot;)).findAny();&#xD;&#xA;MocaTree.Node portName = (MocaTree.Node) matchForPortName.get().getNode();&#xA;&#xA;if(!portNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!typeNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entity.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;eq0.setRuleName(&quot;HandleOutPort&quot;);&#xD;&#xA;eq0.solve(var_portName_name,var_port_name);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_portName_name.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_portName_name,var_port_name);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;portName.setName((String) var_portName_name.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Mapping2AndGate&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForAndNode2Gate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;andNode2Gate&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToBlock andNode2Gate = (VHDLTGGCodeAdapter.NodeToBlock) matchForAndNode2Gate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpression = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expression&quot;)).findAny();&#xD;&#xA;VHDLModel.AndGate expression = (VHDLModel.AndGate) matchForExpression.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpressionNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expressionNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node expressionNode = (MocaTree.Node) matchForExpressionNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftPort = (VHDLModel.InputPort) matchForLeftPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOut = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;out&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort out = (VHDLModel.OutputPort) matchForOut.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightPort = (VHDLModel.InputPort) matchForRightPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode2 = (MocaTree.Node) matchForInNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForCompositeBlock = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;compositeBlock&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock compositeBlock = (VHDLModel.CompositeBlock) matchForCompositeBlock.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityNode = (MocaTree.Node) matchForEntityNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode2 = (MocaTree.Node) matchForInputPortNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeft = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;left&quot;)).findAny();&#xD;&#xA;MocaTree.Node left = (MocaTree.Node) matchForLeft.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftExtern = (VHDLModel.InputPort) matchForLeftExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock node2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForNode2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2inputPort2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2inputPort2&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2inputPort2 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2inputPort2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRight = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;right&quot;)).findAny();&#xD;&#xA;MocaTree.Node right = (MocaTree.Node) matchForRight.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightExtern = (VHDLModel.InputPort) matchForRightExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outNode = (MocaTree.Node) matchForOutNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNodeName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNodeName&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNodeName = (MocaTree.Node) matchForOutputPortNodeName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode = (MocaTree.Node) matchForInNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateNode = (MocaTree.Node) matchForGateNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode1&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode1 = (MocaTree.Node) matchForInputPortNode1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForMapping = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;mapping&quot;)).findAny();&#xD;&#xA;MocaTree.Node mapping = (MocaTree.Node) matchForMapping.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2InputPort1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2InputPort1&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2InputPort1 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2InputPort1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2OutputPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2OutputPort&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2OutputPort = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2OutputPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutExternal = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outExternal&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort outExternal = (VHDLModel.OutputPort) matchForOutExternal.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNode = (MocaTree.Node) matchForOutputPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdlNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdlNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdlNode = (MocaTree.Node) matchForVhdlNode.get().getNode();&#xA;&#xA;if(!expressionNode.getName().equals(&quot;and&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!leftPort.getName().equals(&quot;AND.in1&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!out.getName().equals(&quot;AND.out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!rightPort.getName().equals(&quot;AND.in2&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(left.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!(right.getIndex() == 1)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;Eq eq2 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq2);&#xA;&#xA;NextIndex nextIndex3 = new NextIndex();&#xD;&#xA;csp.getConstraints().add(nextIndex3);&#xA;&#xA;eq0.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;eq0.solve(var_leftExtern_name,var_left_name);&#xA;&#xA;eq1.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;eq1.solve(var_rightExtern_name,var_right_name);&#xA;&#xA;eq2.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xA;&#xA;nextIndex3.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;nextIndex3.solve(var_mapping_index);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;eq0.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;&#x9;eq1.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#x9;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;&#x9;nextIndex3.solve(var_mapping_index);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Mapping2AndGate&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForAndNode2Gate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;andNode2Gate&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToBlock andNode2Gate = (VHDLTGGCodeAdapter.NodeToBlock) matchForAndNode2Gate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpression = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expression&quot;)).findAny();&#xD;&#xA;VHDLModel.AndGate expression = (VHDLModel.AndGate) matchForExpression.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpressionNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expressionNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node expressionNode = (MocaTree.Node) matchForExpressionNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftPort = (VHDLModel.InputPort) matchForLeftPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOut = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;out&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort out = (VHDLModel.OutputPort) matchForOut.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightPort = (VHDLModel.InputPort) matchForRightPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode2 = (MocaTree.Node) matchForInNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForCompositeBlock = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;compositeBlock&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock compositeBlock = (VHDLModel.CompositeBlock) matchForCompositeBlock.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityNode = (MocaTree.Node) matchForEntityNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode2 = (MocaTree.Node) matchForInputPortNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeft = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;left&quot;)).findAny();&#xD;&#xA;MocaTree.Node left = (MocaTree.Node) matchForLeft.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftExtern = (VHDLModel.InputPort) matchForLeftExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock node2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForNode2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2inputPort2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2inputPort2&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2inputPort2 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2inputPort2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRight = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;right&quot;)).findAny();&#xD;&#xA;MocaTree.Node right = (MocaTree.Node) matchForRight.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightExtern = (VHDLModel.InputPort) matchForRightExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outNode = (MocaTree.Node) matchForOutNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNodeName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNodeName&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNodeName = (MocaTree.Node) matchForOutputPortNodeName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode = (MocaTree.Node) matchForInNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateNode = (MocaTree.Node) matchForGateNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode1&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode1 = (MocaTree.Node) matchForInputPortNode1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForMapping = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;mapping&quot;)).findAny();&#xD;&#xA;MocaTree.Node mapping = (MocaTree.Node) matchForMapping.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2InputPort1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2InputPort1&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2InputPort1 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2InputPort1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2OutputPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2OutputPort&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2OutputPort = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2OutputPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutExternal = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outExternal&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort outExternal = (VHDLModel.OutputPort) matchForOutExternal.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNode = (MocaTree.Node) matchForOutputPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdlNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdlNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdlNode = (MocaTree.Node) matchForVhdlNode.get().getNode();&#xA;&#xA;if(!expressionNode.getName().equals(&quot;and&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!leftPort.getName().equals(&quot;AND.in1&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!out.getName().equals(&quot;AND.out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!rightPort.getName().equals(&quot;AND.in2&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(left.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!(right.getIndex() == 1)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;Eq eq2 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq2);&#xA;&#xA;NextIndex nextIndex3 = new NextIndex();&#xD;&#xA;csp.getConstraints().add(nextIndex3);&#xA;&#xA;eq0.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;eq0.solve(var_leftExtern_name,var_left_name);&#xA;&#xA;eq1.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;eq1.solve(var_rightExtern_name,var_right_name);&#xA;&#xA;eq2.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xA;&#xA;nextIndex3.setRuleName(&quot;Mapping2AndGate&quot;);&#xD;&#xA;nextIndex3.solve(var_mapping_index);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_left_name.setBound(false);&#xD;&#xA;&#x9;var_right_name.setBound(false);&#xD;&#xA;&#x9;var_mapping_name.setBound(false);&#xD;&#xA;&#x9;var_mapping_index.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;&#x9;eq1.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#x9;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;&#x9;nextIndex3.solve(var_mapping_index);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;left.setName((String) var_left_name.getValue());&#xD;&#xA;&#x9;&#x9;right.setName((String) var_right_name.getValue());&#xD;&#xA;&#x9;&#x9;mapping.setName((String) var_mapping_name.getValue());&#xD;&#xA;&#x9;&#x9;mapping.setIndex((int) var_mapping_index.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Mapping2OrGate&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpression = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expression&quot;)).findAny();&#xD;&#xA;VHDLModel.OrGate expression = (VHDLModel.OrGate) matchForExpression.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpressionNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expressionNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node expressionNode = (MocaTree.Node) matchForExpressionNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftPort = (VHDLModel.InputPort) matchForLeftPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOrNode2Gate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;orNode2Gate&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToBlock orNode2Gate = (VHDLTGGCodeAdapter.NodeToBlock) matchForOrNode2Gate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOut = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;out&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort out = (VHDLModel.OutputPort) matchForOut.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightPort = (VHDLModel.InputPort) matchForRightPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode2 = (MocaTree.Node) matchForInNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForCompositeBlock = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;compositeBlock&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock compositeBlock = (VHDLModel.CompositeBlock) matchForCompositeBlock.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityNode = (MocaTree.Node) matchForEntityNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode2 = (MocaTree.Node) matchForInputPortNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeft = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;left&quot;)).findAny();&#xD;&#xA;MocaTree.Node left = (MocaTree.Node) matchForLeft.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftExtern = (VHDLModel.InputPort) matchForLeftExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock node2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForNode2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2inputPort2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2inputPort2&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2inputPort2 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2inputPort2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRight = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;right&quot;)).findAny();&#xD;&#xA;MocaTree.Node right = (MocaTree.Node) matchForRight.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightExtern = (VHDLModel.InputPort) matchForRightExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outNode = (MocaTree.Node) matchForOutNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNodeName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNodeName&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNodeName = (MocaTree.Node) matchForOutputPortNodeName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode = (MocaTree.Node) matchForInNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateNode = (MocaTree.Node) matchForGateNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode1&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode1 = (MocaTree.Node) matchForInputPortNode1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForMapping = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;mapping&quot;)).findAny();&#xD;&#xA;MocaTree.Node mapping = (MocaTree.Node) matchForMapping.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2InputPort1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2InputPort1&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2InputPort1 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2InputPort1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2OutputPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2OutputPort&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2OutputPort = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2OutputPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutExternal = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outExternal&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort outExternal = (VHDLModel.OutputPort) matchForOutExternal.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNode = (MocaTree.Node) matchForOutputPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdlNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdlNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdlNode = (MocaTree.Node) matchForVhdlNode.get().getNode();&#xA;&#xA;if(!expressionNode.getName().equals(&quot;or&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!leftPort.getName().equals(&quot;OR.in1&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!out.getName().equals(&quot;OR.out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!rightPort.getName().equals(&quot;OR.in2&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(left.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!(right.getIndex() == 1)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;Eq eq2 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq2);&#xA;&#xA;NextIndex nextIndex3 = new NextIndex();&#xD;&#xA;csp.getConstraints().add(nextIndex3);&#xA;&#xA;eq0.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;eq0.solve(var_leftExtern_name,var_left_name);&#xA;&#xA;eq1.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;eq1.solve(var_rightExtern_name,var_right_name);&#xA;&#xA;eq2.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xA;&#xA;nextIndex3.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;nextIndex3.solve(var_mapping_index);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;eq0.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;&#x9;eq1.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#x9;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;&#x9;nextIndex3.solve(var_mapping_index);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Mapping2OrGate&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpression = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expression&quot;)).findAny();&#xD;&#xA;VHDLModel.OrGate expression = (VHDLModel.OrGate) matchForExpression.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpressionNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expressionNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node expressionNode = (MocaTree.Node) matchForExpressionNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftPort = (VHDLModel.InputPort) matchForLeftPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOrNode2Gate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;orNode2Gate&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToBlock orNode2Gate = (VHDLTGGCodeAdapter.NodeToBlock) matchForOrNode2Gate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOut = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;out&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort out = (VHDLModel.OutputPort) matchForOut.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightPort&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightPort = (VHDLModel.InputPort) matchForRightPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode2 = (MocaTree.Node) matchForInNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForCompositeBlock = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;compositeBlock&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock compositeBlock = (VHDLModel.CompositeBlock) matchForCompositeBlock.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityNode = (MocaTree.Node) matchForEntityNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode2&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode2 = (MocaTree.Node) matchForInputPortNode2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeft = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;left&quot;)).findAny();&#xD;&#xA;MocaTree.Node left = (MocaTree.Node) matchForLeft.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftExtern = (VHDLModel.InputPort) matchForLeftExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock node2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForNode2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2inputPort2 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2inputPort2&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2inputPort2 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2inputPort2.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRight = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;right&quot;)).findAny();&#xD;&#xA;MocaTree.Node right = (MocaTree.Node) matchForRight.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForRightExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;rightExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort rightExtern = (VHDLModel.InputPort) matchForRightExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outNode = (MocaTree.Node) matchForOutNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNodeName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNodeName&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNodeName = (MocaTree.Node) matchForOutputPortNodeName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode = (MocaTree.Node) matchForInNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateNode = (MocaTree.Node) matchForGateNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode1&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode1 = (MocaTree.Node) matchForInputPortNode1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForMapping = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;mapping&quot;)).findAny();&#xD;&#xA;MocaTree.Node mapping = (MocaTree.Node) matchForMapping.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2InputPort1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2InputPort1&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2InputPort1 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2InputPort1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2OutputPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2OutputPort&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2OutputPort = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2OutputPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutExternal = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outExternal&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort outExternal = (VHDLModel.OutputPort) matchForOutExternal.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNode = (MocaTree.Node) matchForOutputPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdlNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdlNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdlNode = (MocaTree.Node) matchForVhdlNode.get().getNode();&#xA;&#xA;if(!expressionNode.getName().equals(&quot;or&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!leftPort.getName().equals(&quot;OR.in1&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!out.getName().equals(&quot;OR.out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!rightPort.getName().equals(&quot;OR.in2&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode2.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode2.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!(left.getIndex() == 0)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!(right.getIndex() == 1)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#x9;&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;Eq eq2 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq2);&#xA;&#xA;NextIndex nextIndex3 = new NextIndex();&#xD;&#xA;csp.getConstraints().add(nextIndex3);&#xA;&#xA;eq0.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;eq0.solve(var_leftExtern_name,var_left_name);&#xA;&#xA;eq1.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;eq1.solve(var_rightExtern_name,var_right_name);&#xA;&#xA;eq2.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xA;&#xA;nextIndex3.setRuleName(&quot;Mapping2OrGate&quot;);&#xD;&#xA;nextIndex3.solve(var_mapping_index);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_left_name.setBound(false);&#xD;&#xA;&#x9;var_right_name.setBound(false);&#xD;&#xA;&#x9;var_mapping_name.setBound(false);&#xD;&#xA;&#x9;var_mapping_index.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;&#x9;eq1.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#x9;eq2.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;&#x9;nextIndex3.solve(var_mapping_index);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;left.setName((String) var_left_name.getValue());&#xD;&#xA;&#x9;&#x9;right.setName((String) var_right_name.getValue());&#xD;&#xA;&#x9;&#x9;mapping.setName((String) var_mapping_name.getValue());&#xD;&#xA;&#x9;&#x9;mapping.setIndex((int) var_mapping_index.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Mapping2NotGate&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpression = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expression&quot;)).findAny();&#xD;&#xA;VHDLModel.NotGate expression = (VHDLModel.NotGate) matchForExpression.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpressionNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expressionNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node expressionNode = (MocaTree.Node) matchForExpressionNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForIn = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;in&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort in = (VHDLModel.InputPort) matchForIn.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftExtern = (VHDLModel.InputPort) matchForLeftExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNotNode2Gate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;notNode2Gate&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToBlock notNode2Gate = (VHDLTGGCodeAdapter.NodeToBlock) matchForNotNode2Gate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOut = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;out&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort out = (VHDLModel.OutputPort) matchForOut.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;port&quot;)).findAny();&#xD;&#xA;MocaTree.Node port = (MocaTree.Node) matchForPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outNode = (MocaTree.Node) matchForOutNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNodeName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNodeName&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNodeName = (MocaTree.Node) matchForOutputPortNodeName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode = (MocaTree.Node) matchForInNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForCompositeBlock = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;compositeBlock&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock compositeBlock = (VHDLModel.CompositeBlock) matchForCompositeBlock.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityNode = (MocaTree.Node) matchForEntityNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateNode = (MocaTree.Node) matchForGateNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode1&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode1 = (MocaTree.Node) matchForInputPortNode1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForMapping = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;mapping&quot;)).findAny();&#xD;&#xA;MocaTree.Node mapping = (MocaTree.Node) matchForMapping.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2InputPort1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2InputPort1&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2InputPort1 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2InputPort1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2OutputPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2OutputPort&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2OutputPort = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2OutputPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutExternal = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outExternal&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort outExternal = (VHDLModel.OutputPort) matchForOutExternal.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNode = (MocaTree.Node) matchForOutputPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdlNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdlNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdlNode = (MocaTree.Node) matchForVhdlNode.get().getNode();&#xA;&#xA;if(!expressionNode.getName().equals(&quot;not&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!in.getName().equals(&quot;NOT.in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!out.getName().equals(&quot;NOT.out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;NextIndex nextIndex2 = new NextIndex();&#xD;&#xA;csp.getConstraints().add(nextIndex2);&#xA;&#xA;eq0.setRuleName(&quot;Mapping2NotGate&quot;);&#xD;&#xA;eq0.solve(var_leftExtern_name,var_port_name);&#xA;&#xA;eq1.setRuleName(&quot;Mapping2NotGate&quot;);&#xD;&#xA;eq1.solve(var_outputPortNodeName_name,var_mapping_name);&#xA;&#xA;nextIndex2.setRuleName(&quot;Mapping2NotGate&quot;);&#xD;&#xA;nextIndex2.solve(var_mapping_index);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;eq0.solve(var_leftExtern_name,var_port_name);&#xD;&#xA;&#x9;eq1.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;&#x9;nextIndex2.solve(var_mapping_index);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/checkAttributes_FWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="AttributeConstraintsRuleResult ruleResult = org.moflon.tgg.runtime.RuntimeFactory.eINSTANCE.createAttributeConstraintsRuleResult();&#xD;&#xA;ruleResult.setRule(&quot;Mapping2NotGate&quot;);&#x9;&#xD;&#xA;ruleResult.setSuccess(true);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpression = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expression&quot;)).findAny();&#xD;&#xA;VHDLModel.NotGate expression = (VHDLModel.NotGate) matchForExpression.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForExpressionNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;expressionNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node expressionNode = (MocaTree.Node) matchForExpressionNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForIn = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;in&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort in = (VHDLModel.InputPort) matchForIn.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForLeftExtern = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;leftExtern&quot;)).findAny();&#xD;&#xA;VHDLModel.InputPort leftExtern = (VHDLModel.InputPort) matchForLeftExtern.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNotNode2Gate = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;notNode2Gate&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToBlock notNode2Gate = (VHDLTGGCodeAdapter.NodeToBlock) matchForNotNode2Gate.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOut = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;out&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort out = (VHDLModel.OutputPort) matchForOut.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;port&quot;)).findAny();&#xD;&#xA;MocaTree.Node port = (MocaTree.Node) matchForPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outNode = (MocaTree.Node) matchForOutNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNodeName = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNodeName&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNodeName = (MocaTree.Node) matchForOutputPortNodeName.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node inNode = (MocaTree.Node) matchForInNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForCompositeBlock = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;compositeBlock&quot;)).findAny();&#xD;&#xA;VHDLModel.CompositeBlock compositeBlock = (VHDLModel.CompositeBlock) matchForCompositeBlock.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntity2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entity2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock entity2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForEntity2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForEntityNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;entityNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node entityNode = (MocaTree.Node) matchForEntityNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGate2composite = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gate2composite&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToCompositeBlock gate2composite = (VHDLTGGCodeAdapter.NodeToCompositeBlock) matchForGate2composite.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForGateNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;gateNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node gateNode = (MocaTree.Node) matchForGateNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForInputPortNode1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;inputPortNode1&quot;)).findAny();&#xD;&#xA;MocaTree.Node inputPortNode1 = (MocaTree.Node) matchForInputPortNode1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForMapping = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;mapping&quot;)).findAny();&#xD;&#xA;MocaTree.Node mapping = (MocaTree.Node) matchForMapping.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2InputPort1 = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2InputPort1&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToInputPort node2InputPort1 = (VHDLTGGCodeAdapter.NodeToInputPort) matchForNode2InputPort1.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForNode2OutputPort = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;node2OutputPort&quot;)).findAny();&#xD;&#xA;VHDLTGGCodeAdapter.NodeToOutputPort node2OutputPort = (VHDLTGGCodeAdapter.NodeToOutputPort) matchForNode2OutputPort.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutExternal = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outExternal&quot;)).findAny();&#xD;&#xA;VHDLModel.OutputPort outExternal = (VHDLModel.OutputPort) matchForOutExternal.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForOutputPortNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;outputPortNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node outputPortNode = (MocaTree.Node) matchForOutputPortNode.get().getNode();&#xA;&#xA;Optional&lt;TripleMatchNodeMapping> matchForVhdlNode = __tripleMatch.getNodeMappings().stream().filter(nm -> nm.getNodeName().equals(&quot;vhdlNode&quot;)).findAny();&#xD;&#xA;MocaTree.Node vhdlNode = (MocaTree.Node) matchForVhdlNode.get().getNode();&#xA;&#xA;if(!expressionNode.getName().equals(&quot;not&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!in.getName().equals(&quot;NOT.in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!out.getName().equals(&quot;NOT.out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outNode.getName().equals(&quot;out&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inNode.getName().equals(&quot;in&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!entityNode.getName().equals(&quot;ENTITY&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!gateNode.getName().equals(&quot;GATE&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!inputPortNode1.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!outputPortNode.getName().equals(&quot;PORT&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;if(!vhdlNode.getName().equals(&quot;VHDL&quot;)){ &#xD;&#xA;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;return ruleResult;&#xD;&#xA;}&#xA;&#xA;&#xA;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_name.setValue(mapping.getName());&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xA;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping&quot;, true, csp);&#xD;&#xA;var_mapping_index.setValue(mapping.getIndex());&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xA;&#xA;Eq eq0 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq0);&#xA;&#xA;Eq eq1 = new Eq();&#xD;&#xA;csp.getConstraints().add(eq1);&#xA;&#xA;NextIndex nextIndex2 = new NextIndex();&#xD;&#xA;csp.getConstraints().add(nextIndex2);&#xA;&#xA;eq0.setRuleName(&quot;Mapping2NotGate&quot;);&#xD;&#xA;eq0.solve(var_leftExtern_name,var_port_name);&#xA;&#xA;eq1.setRuleName(&quot;Mapping2NotGate&quot;);&#xD;&#xA;eq1.solve(var_outputPortNodeName_name,var_mapping_name);&#xA;&#xA;nextIndex2.setRuleName(&quot;Mapping2NotGate&quot;);&#xD;&#xA;nextIndex2.solve(var_mapping_index);&#xA;&#xA;if(csp.check()){ &#xD;&#xA;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;} else {&#xD;&#xA;&#x9;var_port_name.setBound(false);&#xD;&#xA;&#x9;var_mapping_name.setBound(false);&#xD;&#xA;&#x9;var_mapping_index.setBound(false);&#xD;&#xA;&#x9;eq0.solve(var_leftExtern_name,var_port_name);&#xD;&#xA;&#x9;eq1.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;&#x9;nextIndex2.solve(var_mapping_index);&#xD;&#xA;&#x9;if(csp.check()){ &#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(true);&#xD;&#xA;&#x9;&#x9;ruleResult.setRequiredChange(true);&#xD;&#xA;&#x9;&#x9;port.setName((String) var_port_name.getValue());&#xD;&#xA;&#x9;&#x9;mapping.setName((String) var_mapping_name.getValue());&#xD;&#xA;&#x9;&#x9;mapping.setIndex((int) var_mapping_index.getValue());&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;ruleResult.setSuccess(false);&#xD;&#xA;&#x9;&#x9;return ruleResult;&#xD;&#xA;&#x9;}&#x9;&#x9;&#xD;&#xA;}&#x9;&#xA;&#xA;return ruleResult;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/checkAttributes_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName.name&quot;, true, csp);&#xD;&#xA;var_entityName_name.setValue(entityName.getName());&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_composite_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;composite.name&quot;, true, csp);&#xD;&#xA;var_composite_name.setValue(composite.getName());&#xD;&#xA;var_composite_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName.name&quot;, true, csp);&#xD;&#xA;var_gateName_name.setValue(gateName.getName());&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_entityName_name,var_composite_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_gateName_name,var_composite_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityName&quot;,entityName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file2spec&quot;,file2spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file&quot;,file);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate&quot;,gate);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateName&quot;,gateName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;spec&quot;,spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdl&quot;,vhdl);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;port&quot;,port);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portName&quot;,portName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portNode&quot;,portNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;typeNode&quot;,typeNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;Variable literal0 = CSPFactoryHelper.eINSTANCE.createVariable(&quot;literal0&quot;, true, csp);&#xD;&#xA;literal0.setValue(&quot;.vhdl&quot;);&#xD;&#xA;literal0.setType(&quot;&quot;);&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_spec_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;spec.name&quot;, true, csp);&#xD;&#xA;var_spec_name.setValue(spec.getName());&#xD;&#xA;var_spec_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_file_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;file.name&quot;, true, csp);&#xD;&#xA;var_file_name.setValue(file.getName());&#xD;&#xA;var_file_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;AddPrefix addPrefix = new AddPrefix();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(addPrefix);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;addPrefix.setRuleName(&quot;&quot;);&#xD;&#xA;addPrefix.solve(var_spec_name,literal0,var_file_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;file&quot;,file);&#xD;&#xA;isApplicableMatch.registerObject(&quot;spec&quot;,spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdl&quot;,vhdl);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, true, csp);&#xD;&#xA;var_portName_name.setValue(portName.getName());&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;port&quot;,port);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portNode&quot;,portNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;typeNode&quot;,typeNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;isApplicableMatch.registerObject(&quot;portName&quot;,portName);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expression&quot;,expression);&#xD;&#xA;isApplicableMatch.registerObject(&quot;expressionNode&quot;,expressionNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftPort&quot;,leftPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;out&quot;,out);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightPort&quot;,rightPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;left&quot;,left);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;right&quot;,right);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;mapping&quot;,mapping);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, true, csp);&#xD;&#xA;var_left_name.setValue(left.getName());&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, true, csp);&#xD;&#xA;var_right_name.setValue(right.getName());&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expression&quot;,expression);&#xD;&#xA;isApplicableMatch.registerObject(&quot;expressionNode&quot;,expressionNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftPort&quot;,leftPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;out&quot;,out);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightPort&quot;,rightPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;left&quot;,left);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;right&quot;,right);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;mapping&quot;,mapping);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, true, csp);&#xD;&#xA;var_port_name.setValue(port.getName());&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;expression&quot;,expression);&#xD;&#xA;isApplicableMatch.registerObject(&quot;expressionNode&quot;,expressionNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;in&quot;,in);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;out&quot;,out);&#xD;&#xA;isApplicableMatch.registerObject(&quot;port&quot;,port);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;mapping&quot;,mapping);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isApplicable_solveCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/isApplicable_checkCsp_CC"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_entityName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;entityName.name&quot;, csp);&#xD;&#xA;var_entityName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_composite_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;composite.name&quot;, csp);&#xD;&#xA;var_composite_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_gateName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;gateName.name&quot;, csp);&#xD;&#xA;var_gateName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;Eq eq_1 = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(eq_1);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_entityName_name,var_composite_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_gateName_name,var_composite_name);&#xD;&#xA;eq_1.setRuleName(&quot;&quot;);&#xD;&#xA;eq_1.solve(var_gateName_name,var_entityName_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;file2spec&quot;,file2spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;file&quot;,file);&#xD;&#xA;isApplicableMatch.registerObject(&quot;spec&quot;,spec);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdl&quot;,vhdl);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, csp);&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, csp);&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;Variable literal0 = CSPFactoryHelper.eINSTANCE.createVariable(&quot;literal0&quot;, true, csp);&#xD;&#xA;literal0.setValue(&quot;.vhdl&quot;);&#xD;&#xA;literal0.setType(&quot;&quot;);&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_spec_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;spec.name&quot;, csp);&#xD;&#xA;var_spec_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_file_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;file.name&quot;, csp);&#xD;&#xA;var_file_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;AddPrefix addPrefix = new AddPrefix();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(addPrefix);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;addPrefix.setRuleName(&quot;&quot;);&#xD;&#xA;addPrefix.solve(var_spec_name,literal0,var_file_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_portName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;portName.name&quot;, csp);&#xD;&#xA;var_portName_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, csp);&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_portName_name,var_port_name);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;composite&quot;,composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity&quot;,entity);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, csp);&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, csp);&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, csp);&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, csp);&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;Eq eq_1 = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(eq_1);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;eq_1.setRuleName(&quot;&quot;);&#xD;&#xA;eq_1.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_rightExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;rightExtern.name&quot;, true, csp);&#xD;&#xA;var_rightExtern_name.setValue(rightExtern.getName());&#xD;&#xA;var_rightExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_left_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;left.name&quot;, csp);&#xD;&#xA;var_left_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_right_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;right.name&quot;, csp);&#xD;&#xA;var_right_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, csp);&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, csp);&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;Eq eq_1 = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(eq_1);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_left_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_rightExtern_name,var_right_name);&#xD;&#xA;eq_1.setRuleName(&quot;&quot;);&#xD;&#xA;eq_1.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode2&quot;,inNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode2&quot;,inputPortNode2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2composite&quot;,node2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2inputPort2&quot;,node2inputPort2);&#xD;&#xA;isApplicableMatch.registerObject(&quot;rightExtern&quot;,rightExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="// Create CSP&#xD;&#xA;CSP csp = CspFactory.eINSTANCE.createCSP();&#xD;&#xA;isApplicableMatch.getAttributeInfo().add(csp);&#xD;&#xA;&#xD;&#xA;// Create literals&#xD;&#xA;&#xD;&#xA;// Create attribute variables&#xD;&#xA;Variable var_leftExtern_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;leftExtern.name&quot;, true, csp);&#xD;&#xA;var_leftExtern_name.setValue(leftExtern.getName());&#xD;&#xA;var_leftExtern_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_outputPortNodeName_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;outputPortNodeName.name&quot;, true, csp);&#xD;&#xA;var_outputPortNodeName_name.setValue(outputPortNodeName.getName());&#xD;&#xA;var_outputPortNodeName_name.setType(&quot;String&quot;);&#xD;&#xA;&#xD;&#xA;// Create unbound variables&#xD;&#xA;Variable var_port_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;port.name&quot;, csp);&#xD;&#xA;var_port_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_name = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.name&quot;, csp);&#xD;&#xA;var_mapping_name.setType(&quot;String&quot;);&#xD;&#xA;Variable var_mapping_index = CSPFactoryHelper.eINSTANCE.createVariable(&quot;mapping.index&quot;, csp);&#xD;&#xA;var_mapping_index.setType(&quot;int&quot;);&#xD;&#xA;&#xD;&#xA;// Create constraints&#xD;&#xA;Eq eq = new Eq();&#xD;&#xA;Eq eq_0 = new Eq();&#xD;&#xA;NextIndex nextIndex = new NextIndex();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;csp.getConstraints().add(eq);&#xD;&#xA;csp.getConstraints().add(eq_0);&#xD;&#xA;csp.getConstraints().add(nextIndex);&#xD;&#xA;&#xD;&#xA;// Solve CSP&#xD;&#xA;eq.setRuleName(&quot;&quot;);&#xD;&#xA;eq.solve(var_leftExtern_name,var_port_name);&#xD;&#xA;eq_0.setRuleName(&quot;&quot;);&#xD;&#xA;eq_0.solve(var_outputPortNodeName_name,var_mapping_name);&#xD;&#xA;nextIndex.setRuleName(&quot;&quot;);&#xD;&#xA;nextIndex.solve(var_mapping_index);&#xD;&#xA;&#xD;&#xA;// Snapshot pattern match on which CSP is solved&#xD;&#xA;isApplicableMatch.registerObject(&quot;leftExtern&quot;,leftExtern);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outNode&quot;,outNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNodeName&quot;,outputPortNodeName);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inNode&quot;,inNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;compositeBlock&quot;,compositeBlock);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entity2composite&quot;,entity2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;entityNode&quot;,entityNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gate2composite&quot;,gate2composite);&#xD;&#xA;isApplicableMatch.registerObject(&quot;gateNode&quot;,gateNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;inputPortNode1&quot;,inputPortNode1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2InputPort1&quot;,node2InputPort1);&#xD;&#xA;isApplicableMatch.registerObject(&quot;node2OutputPort&quot;,node2OutputPort);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outExternal&quot;,outExternal);&#xD;&#xA;isApplicableMatch.registerObject(&quot;outputPortNode&quot;,outputPortNode);&#xD;&#xA;isApplicableMatch.registerObject(&quot;vhdlNode&quot;,vhdlNode);&#xD;&#xA;return csp;">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/generateModel_solveCsp_BWD"/>
  </compilerInjectionEntries>
  <compilerInjectionEntries content="return csp.check();">
    <eOperation href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate/generateModel_checkCsp_BWD"/>
  </compilerInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="csp.constraints.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.language.csp.*">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Entity2CompositeBlock"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleInPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/File2VHDLSpec"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/HandleOutPort"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2AndGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2OrGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="org.moflon.tgg.runtime.TripleMatchNodeMapping">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
  <importInjectionEntries content="java.util.Optional">
    <eClass href="platform:/plugin/VHDLTGGCodeAdapter/model/VHDLTGGCodeAdapter.ecore#//Rules/Mapping2NotGate"/>
  </importInjectionEntries>
</sdmUtil:CompilerInjection>
